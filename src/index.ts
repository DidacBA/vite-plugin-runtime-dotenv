import { loadEnv, type Plugin, type ResolvedConfig } from 'vite';
import MagicString from 'magic-string';
import { relative, resolve } from 'path';
import { cpSync, rmSync, writeFileSync } from 'fs';
import { ensureDirectoryExists, trimBasePath } from './utils';

export interface Options {
  output: string;
  modes: string[];
  globalVariableName?: string;
  generateDts?: boolean;
  defaultEnvFilenameAliases?: { production?: string, development?: string };
}

export interface NormalizedOptions extends Options {
  fullPath: string;
  relativePath: string;
}

const viteDefaultModes = ['production', 'development'];
const viteReservedEnvs = ['BASE_URL', 'MODE', 'PROD', 'DEV', 'SSR'];
let config: ResolvedConfig;
let distPath: string;
let normalizedOptions: NormalizedOptions;
const envVars = new Map<string, Record<string, string>>;

function normalizeOptions(options: Options): NormalizedOptions {
  const fullPath = resolve(distPath, options.output);
  const relativePath = `/${relative(distPath, fullPath)}`;

  return {
    ...options,
    fullPath,
    relativePath,
    globalVariableName: options.globalVariableName || 'runtimeEnv',
  };
}

function generateContent(mode: string, options: NormalizedOptions) {
  const env = envVars.get(mode);

  if (!env) return '';

  return `// Generated by 'vite-plugin-runtime-dotenv'\n\n` +
    `globalThis.${options.globalVariableName} = {\n` +
    `${Object.keys(env)
        .map((key) => `  ${JSON.stringify(key)}: ${JSON.stringify(env[key])}`)
        .join(',\n')}` +
    `\n};\n`;
}

function generateDts(mode: string) {
  const envVarNames = loadEnv(mode, process.cwd());
  const dtsPath = resolve('src', 'runtime-env.d.ts');

  const content = `// This file is generated by 'vite-pugin-runtime-dotenv\n\n` +
    `interface ImportMetaEnv {\n` +
    `${Object.keys(envVarNames)
      .map((key) => `  readonly ${key}: string;`)
      .join('\n')}\n` +
    `};\n\n` +
    `interface ImportMeta {\n` +
    `  readonly env: ImportMetaEnv;\n` +
    `}\n`;

  ensureDirectoryExists(dtsPath);
  writeFileSync(dtsPath, content, { flag: 'w' });
}

function generateFile(mode: string, options: NormalizedOptions) {
  const filePath = resolve(distPath, options.output);
  const fileContent = generateContent(mode, options);

  ensureDirectoryExists(filePath);
  writeFileSync(filePath, fileContent, { flag: 'w' });
}

export function runtimeEnv(options: Options): Plugin {
  let mode: string;
  return {
    name: 'vite-plugin-runtime-dotenv',
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      distPath = resolve(config.root, config.build.outDir),
      normalizedOptions = normalizeOptions(options);
      mode = config.env.MODE;
      if (viteDefaultModes.includes(mode) && !options.modes.includes(config.env.MODE)) {
        if (options.defaultEnvFilenameAliases?.[config.env.MODE as 'production' | 'development']) {
          mode = options.defaultEnvFilenameAliases[config.env.MODE as 'production' | 'development'] as string;
        } else {
          throw new Error(`vite-plugin-runtime-env: No env file found for mode ${config.env.MODE}`);
        }
      }
      [mode, ...options.modes].forEach((mode) => {
        const env = loadEnv(mode, process.cwd());
        if (!envVars.has(mode)) {
          envVars.set(mode, env);
        }
      });
    },
    transform(code) {
      const magicString = new MagicString(code);
      const importMetaRegExp = /import\.meta\.env\.([A-Z0-9_]+)/g;
      let match: RegExpExecArray | null;

      while (match = importMetaRegExp.exec(code)) {
        const start = match.index;
        const end = start + match[0].length;
        const varName = match[1];

        if (!viteReservedEnvs.includes(varName)) {
          magicString.overwrite(start, end, `globalThis.${normalizedOptions.globalVariableName}.${varName}`);
        }
      }

      if (!magicString.hasChanged()) {
        return null;
      }
    
      if (config.build.sourcemap) {
        return {
          code: magicString.toString(),
          map: magicString.generateMap({ hires: true }),
        }
      }
    
      return magicString.toString();
    },
    transformIndexHtml() {
      return [
        {
          tag: 'script',
          attrs: {
            src: options.output ? `${options.output}` : '/runtime-env.js'
          },
          injectTo: 'head-prepend',
        }
      ];
    },
    closeBundle() {
      if (config.command === 'serve') {
        return;
      }

      options.modes.forEach((mode) => {
        const tempDir = `temp-dist/${config.build.outDir}/${mode}`;
        generateFile(mode, normalizedOptions);
        cpSync(config.build.outDir, tempDir, { recursive: true });
      });

      rmSync(config.build.outDir, { recursive: true });
      cpSync(`temp-dist/${config.build.outDir}`, config.build.outDir, { recursive: true });
      rmSync('temp-dist', { recursive: true });
    },
    configureServer(server) {
      server.watcher.add('.env*');

      const listener = async (path: string) => {
        const relativePath = relative(config.root, path);
        if (relativePath.startsWith('.env') && options.generateDts) {
          generateDts(mode);
        }
      };

      server.watcher.on('change', listener);
      server.watcher.on('add', listener);

      server.middlewares.use((req, res, next) => {
        const uri = new URL(req.originalUrl!, `http://${req.headers.host}`);
        const pathname = uri.pathname;
        const base = server.config.base || '/';
        const trimmedPathname = trimBasePath(pathname, base);

        if (pathname === normalizedOptions.relativePath || trimmedPathname === normalizedOptions.relativePath) {
          const content = generateContent(config.env.MODE, normalizedOptions);
          res.writeHead(200, {
            'content-type': 'application/javascript',
          });
          res.write(content);
          res.end();
        } else {
          next();
        }
      });
    },
    buildStart() {
      if (options.generateDts) generateDts(mode);
    }
  }
}
